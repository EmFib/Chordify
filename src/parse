from selenium.webdriver import Chrome
from bs4 import BeautifulSoup
import pymongo
import datetime
import time
import pandas as pd
import re


mc = pymongo.MongoClient()
db = mc['chordify']
raw_html = db['raw_html']


html_docs = list(raw_html.find())


def get_lines_from_songs(html_docs):
    for doc in html_docs:
        html = doc['html']
        soup = BeautifulSoup(html, 'html.parser')
        song_body = soup.select_one('pre._1YgOS')
        lines = str(song_body).split('\n')
        return lines


def parse_lines(lines):
    parsed_lines = []
    for line in lines:
        if '_3L0Da' in line:
            parsed_lines.append({'chords': strip_html(line)})
        elif line and strip_html(line) == line:
            parsed_lines[-1]['words'] = line
    return parsed_lines


def get_chords(parsed_line):
    chord_idxs = []
    chords = []
    c_string = parsed_line['chords']
    for chord in re.finditer('\w+', c_string):
        chord_idxs.append(chord.start())
        chords.append(chord.group())
    chord_tups = list(zip(chord_idxs, chords))
    return chord_idxs, chords, chord_tups


def get_words(parsed_line):
    word_idxs = []
    words = []
    w_string = parsed_line['words']
    for word in re.finditer('\w+', w_string):
        word_idxs.append(word.start())
        words.append(word.group())
    word_tups = list(zip(word_idxs, words))
    return word_idxs, words, word_tups


def match_ch_wd(parsed_line):
    word_tups = get_words(parsed_line)[2]
    chord_tups = get_chords(parsed_line)[2]
    word_list = get_words(parsed_line)[1]
    word_chord_idx_list = []
    for ch_tup in chord_tups:
        for i, wd_tup in enumerate(word_tups):
            if wd_tup[0] > ch_tup[0]:
                word_chord_idx_list.append((i-1, ch_tup[1]))
                break
    return (word_chord_idx_list, word_list)


def combine_ch_wd_list(parsed_line_0, parsed_line_1):
    ch_tups_0, wd_list_0 = match_ch_wd(parsed_line_0)
    ch_tups_1, wd_list_1 = match_ch_wd(parsed_line_1)
    new_tups = []
#     combo_lists = []
    for ch_tup_1 in ch_tups_1:
        new_tups.append( ( ((ch_tup_1)[0]+len(wd_list_0)), ch_tup_1[1] ) )
    combo_tups = ch_tups_0 + new_tups
    combo_lists = wd_list_0 + wd_list_1
    return combo_tups, combo_lists

def parse_song(parsed_lines):
    for i, parsed_line in enumerate(parsed_lines):
        get_chords(parsed_line)
        get_words(parsed_line)
        match_ch_wd(parsed_line)
        if i < (len(parsed_lines) - 1):
            song_wc_idx_list, song_word_list = combine_ch_wd_list(parsed_lines[i], parsed_lines[i+1])
    return song_wc_idx_list, song_word_list
