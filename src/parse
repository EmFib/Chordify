# from selenium.webdriver import Chrome
from bs4 import BeautifulSoup
import pymongo
import datetime
import time
import pandas as pd
import re


mc = pymongo.MongoClient()
db = mc['chordify']
raw_html = db['raw_html']


html_docs = list(raw_html.find())


def get_lines_from_song(html_doc):
    html = html_doc['html']
    soup = BeautifulSoup(html, 'html.parser')
    song_body = soup.select_one('pre._1YgOS')
    lines = str(song_body).split('\n')
    return lines


def strip_html(text):
    result = []
    in_tag = False
    for char in text:
        if char == '<':
            in_tag = True
        if not in_tag:
            result.append(char)
        if char == '>':
            in_tag = False
    return ''.join(result)


def parse_lines(html_doc):
    lines = get_lines_from_song(html_doc)
    parsed_lines = []
    for i, line in enumerate(lines):
        if '_3L0Da' in line:
            parsed_lines.append({'chords': strip_html(line)})
        elif (('_3L0Da' in lines[i-1]) and (line == line) and (strip_html(line) == line)):
            parsed_lines[-1]['words'] = line
    return parsed_lines


def get_chords(parsed_line):
    chord_idxs = []
    chords = []
    c_string = parsed_line['chords']
    for chord in re.finditer('\w+', c_string):
        chord_idxs.append(chord.start())
        chords.append(chord.group())
    chord_tups = list(zip(chord_idxs, chords))
    return chord_idxs, chords, chord_tups


def get_words(parsed_line):
    word_idxs = []
    words = []
    if 'words'in parsed_line:
        w_string = parsed_line['words']
        for word in re.finditer('\w+', w_string):
            word_idxs.append(word.start())
            words.append(word.group())
    word_tups = list(zip(word_idxs, words))
    return word_idxs, words, word_tups


def merge_chord_word(parsed_line):
    chord_tups = get_chords(parsed_line)[2]
    word_tups = get_words(parsed_line)[2]
    word_list = get_words(parsed_line)[1]
    chord_idx_list = []
    for chord_tup in chord_tups:
        for i, word_tup in enumerate(word_tups):
            if word_tup[0] > chord_tup[0]:
                chord_idx_list.append((i-1, chord_tup[1]))
                break
    return (chord_idx_list, word_list)


def combine_ch_wd_lists(merged_line_1, merged_line_2):
    chord_idx_list_1, word_list_1 = merged_line_1
    chord_idx_list_2, word_list_2 = merged_line_2
    new_chord_tups = []
    for chord_idx_tup in chord_idx_list_2:
        new_chord_tups.append( ( ((chord_idx_tup)[0]+len(word_list_1)), chord_idx_tup[1] ) )
    all_chords_tups = chord_idx_list_1 + new_chord_tups
    all_words_list = word_list_1 + word_list_2
    return all_chords_tups, all_words_list


def parse_song(parsed_lines):
    for i, parsed_line in enumerate(parsed_lines):
        if i == 0:
            merged_line = merge_chord_word(parsed_line)
        else:
            merged_line_next = merge_chord_word(parsed_line)
            merged_line = combine_ch_wd_lists(merged_line, merged_line_next)
    return merged_line
